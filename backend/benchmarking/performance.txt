Test case d1-direct-path                 resulted in actions [((5, 6), 0), (6, 2)]
Test case d1-shift-req                   resulted in actions [((1, 6), 0), (0, 3)]
Test case d2-two-shifts                  resulted in actions [((0, 1), 0), (4, 5), ((0, 5), 0), (6, 6)]
Test case d2-self-push-out               resulted in actions [((0, 1), 0), (0, 5), ((6, 5), 90), (6, 6)]
Test case d2-pushback-violation          resulted in actions [((0, 1), 180), (0, 1), ((6, 1), 90), (6, 0)]
Test case d2-long-running                resulted in actions [((0, 5), 0), (3, 0), ((3, 6), 0), (1, 5)]
Test case d3-obj-push-out                resulted in actions [((0, 1), 0), (0, 6), ((0, 1), 0), (0, 6), ((1, 6), 0), (1, 6)]
Test case d3-long-running                resulted in actions [((0, 1), 0), (4, 6), ((3, 6), 0), (3, 6), ((3, 0), 0), (2, 1)]
Test case d3-generated-8s                resulted in actions [((0, 1), 90), (1, 4), ((1, 6), 0), (1, 3), ((6, 3), 0), (6, 2)]
Test case d3-generated-23s               resulted in actions [((0, 1), 90), (6, 6), ((6, 3), 0), (6, 6), ((0, 5), 0), (0, 0)]
Test case d3-generated-33s               resulted in actions [((5, 6), 0), (1, 4), ((0, 3), 0), (1, 4), ((0, 3), 0), (5, 5)]
After no-pushback-rule:
Test case d1-direct-path                 resulted in actions [((5, 6), 0), (6, 2)]
Test case d1-shift-req                   resulted in actions [((1, 6), 0), (0, 3)]
Test case d2-two-shifts                  resulted in actions [((0, 1), 0), (4, 5), ((0, 5), 0), (6, 6)]
Test case d2-self-push-out               resulted in actions [((0, 1), 0), (0, 5), ((6, 5), 90), (6, 6)]
Test case d2-pushback-violation          resulted in actions [((6, 1), 0), (0, 1), ((6, 1), 180), (6, 0)]
Test case d2-long-running                resulted in actions [((0, 5), 0), (3, 0), ((3, 6), 0), (1, 5)]
Test case d3-obj-push-out                resulted in actions [((0, 1), 0), (0, 6), ((0, 1), 0), (0, 6), ((1, 6), 0), (1, 6)]
Test case d3-long-running                resulted in actions [((0, 1), 0), (4, 5), ((6, 5), 0), (3, 6), ((3, 0), 0), (2, 1)]
Test case d3-generated-8s                resulted in actions [((0, 1), 90), (1, 4), ((1, 6), 0), (1, 3), ((6, 3), 0), (6, 2)]
Test case d3-generated-23s               resulted in actions [((0, 1), 90), (6, 6), ((6, 3), 0), (6, 6), ((0, 5), 0), (0, 0)]
Test case d3-generated-33s               resulted in actions [((5, 6), 0), (1, 4), ((0, 3), 0), (1, 4), ((0, 3), 0), (5, 5)]
->d3 long running and d2-pushback-violation have to use different paths, but the depths stays the same

First implementation:
Test case d1-direct-path         best of 3: 11.78ms
Test case d1-shift-req           best of 3: 27.30ms
Test case d2-two-shifts          best of 3: 748.54ms
Test case d2-self-push-out       best of 3: 179.97ms
Test case d2-long-running        best of 3: 27277.45ms
Test case d3-obj-push-out        best of 3: 7395.12ms
Test case d3-long-running        best of 3: 9826.71ms
Test case d3-generated-8s        best of 3: 7291.56ms
Test case d3-generated-23s       best of 3: 22331.70ms
Test case d3-generated-33s       best of 3: 28034.21ms

Caching reachable_locations (computing once instead of twice per node):
Test case d1-direct-path         best of 3: 11.34ms
Test case d1-shift-req           best of 3: 26.08ms
Test case d2-two-shifts          best of 3: 747.43ms
Test case d2-self-push-out       best of 3: 177.10ms
Test case d2-long-running        best of 3: 27652.26ms
Test case d3-obj-push-out        best of 3: 6928.46ms
Test case d3-long-running        best of 3: 9166.55ms
Test case d3-generated-8s        best of 3: 6958.76ms
Test case d3-generated-23s       best of 3: 21122.86ms
Test case d3-generated-33s       best of 3: 27975.67ms
-> No significant impact

Straight leftover only required two different rotations to try:
Test case d1-direct-path         best of 3: 11.29ms
Test case d1-shift-req           best of 3: 25.85ms
Test case d2-two-shifts          best of 3: 751.50ms
Test case d2-self-push-out       best of 3: 115.44ms
Test case d2-long-running        best of 3: 27987.16ms
Test case d3-obj-push-out        best of 3: 5638.81ms
Test case d3-long-running        best of 3: 4242.02ms
Test case d3-generated-8s        best of 3: 5233.23ms
Test case d3-generated-23s       best of 3: 15570.14ms
Test case d3-generated-33s       best of 3: 12037.69ms
-> Faster by a factor of two for the test cases where the leftover is a straight

No new node for each move, instead regard all reached maze cards at once with multi-start bfs:
Test case d1-direct-path         best of 3: 13.06ms
Test case d1-shift-req           best of 3: 28.20ms
Test case d2-two-shifts          best of 3: 129.73ms
Test case d2-self-push-out       best of 3: 66.99ms
Test case d2-long-running        best of 3: 2868.10ms
Test case d3-obj-push-out        best of 3: 1930.92ms
Test case d3-long-running        best of 3: 1699.68ms
Test case d3-generated-8s        best of 3: 3515.96ms
Test case d3-generated-23s       best of 3: 4257.29ms
Test case d3-generated-33s       best of 3: 8038.63ms
-> Nearly everything much faster, up to factor of 10 for d2-long-running, presumably because it reached a many locations at depth 1.
Slight overhead noticable for depth 1. 

After respecting no-pushback-rule, timeings differ in all directions.
The reason for the changes in running time is the alteration of search order, due to the usage of set.difference() to implement the no-pushback-rule. 
To make comparison to the old values easier, I implement the rule with an if-statement to keep search order the same:
Test case d1-direct-path         best of 3: 12.28ms
Test case d1-shift-req           best of 3: 28.07ms
Test case d2-two-shifts          best of 3: 117.32ms
Test case d2-self-push-out       best of 3: 64.33ms
Test case d2-pushback-violation  best of 3: 419.72ms
Test case d2-long-running        best of 3: 2597.17ms
Test case d3-obj-push-out        best of 3: 1778.15ms
Test case d3-long-running        best of 3: 1748.26ms
Test case d3-generated-8s        best of 3: 3042.44ms
Test case d3-generated-23s       best of 3: 3645.34ms
Test case d3-generated-33s       best of 3: 7006.33ms
-> Slight improvement of about 15% for the d3 cases. d3-long-running is slightly slower, because it has to find another solution.

After small refactoring of Board (insert locations now static, start locations now local variable):
Test case d1-direct-path                 best of 3: 10.50ms
Test case d1-shift-req                   best of 3: 24.57ms
Test case d2-two-shifts                  best of 3: 105.56ms
Test case d2-self-push-out               best of 3: 56.08ms
Test case d2-pushback-violation          best of 3: 352.45ms
Test case d2-long-running                best of 3: 2399.78ms
Test case d3-obj-push-out                best of 3: 1487.31ms
Test case d3-long-running                best of 3: 1508.94ms
Test case d3-generated-8s                best of 3: 2517.32ms
Test case d3-generated-23s               best of 3: 3133.73ms
Test case d3-generated-33s               best of 3: 5683.61ms
-> already small removals of members to be copied has a big impact on the running time.

Now implementing deep copy myself, instead of using copy.deepcopy(). 
First try: external method with constructor calls and mapping maze cards from ids for objective and piece maze card
Test case d1-direct-path                 best of 3: 5.93ms
Test case d1-shift-req                   best of 3: 15.67ms
Test case d2-two-shifts                  best of 3: 74.67ms
Test case d2-self-push-out               best of 3: 21.80ms
Test case d2-pushback-violation          best of 3: 146.85ms
Test case d2-long-running                best of 3: 1864.24ms
Test case d3-obj-push-out                best of 3: 639.97ms
Test case d3-long-running                best of 3: 737.72ms
Test case d3-generated-8s                best of 3: 1006.78ms
Test case d3-generated-23s               best of 3: 1727.62ms
Test case d3-generated-33s               best of 3: 2325.37ms
-> Big impact, all d3 below 3 seconds.